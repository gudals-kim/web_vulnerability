# 👀 hacking scenario

## description
- OWASP 2013 에 기술된 취약점을 분석합니다.
- 가장 기본적인 해킹부터 시도 후 분석하고 수정합니다.

## 🐥 summary
1. sql injection
2. parameter 변조
3. Broken Authentication and Session Management
4. xxs

---

### 1. sql Injection

#### 공격

<img src="https://github.com/gudals-kim/web_vulnerability/blob/delevlop/web/docs/ver1/img/sqlinjection.png?raw=true">

#### 결과

> item 테이블이 drop 되었다. 

#### 기존 코드
```java
public item findDescription(String description)
    String sql = "select * from item where item_description = "+description
    ... 
    생략
    ...
```
- 여기서 description이 string으로 "; drop table Item if exists cascade;" 으로 더하지는 연산이 되기 때문에
- 앞의 쿼리가 나가고 그다음 쿼리인 drop table Item if exists cascade;가 나가서 item 테이블이 drop 되었다.

#### 수정 코드
```java
public item findDescription(String description)
    String sql = "select * from item where item_description = ? "
    pstmt.setString(1,description);
    ... 
    생략
    ...
```
> 바인딩을 이용하여 sql인젝션의 위험도를 낮추었다.


---

### 2. parameter 변조

#### 공격
<img src="https://github.com/gudals-kim/web_vulnerability/blob/delevlop/web/docs/ver1/img/parameter1.png?raw=true">

> 기존에 이재용으로 로그인을 했다. 하지만 주소창의 memberId에 해당하는 파라미터 2를 1로 바꾸는 공격을 했다.

#### 결과

<img src="https://github.com/gudals-kim/web_vulnerability/blob/delevlop/web/docs/ver1/img/parameter2.png?raw=true">

> memberId 1 인 이병철로 바뀌는 취약점이 발견되었다.

- url 의 쿼리 파라미터에 다양한 값을 넣었을때 권한이 없는 사용자가 다양한 접근을 할 수 있는 문제가 생겼다.

#### 수정코드
```java
@Slf4j
public class LoginCheckInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        String requestURI = request.getRequestURI();
        log.info("인증 체크 인터셉터 실행 {}", requestURI);

        HttpSession session = request.getSession();
        if (session==null || session.getAttribute(LOGIN_MEMBER)==null){
            log.info("미인증 사용자 요청");
            response.sendRedirect("/login?redirectURL="+requestURI);
            return false;
        }
        return true;
    }
}
```
- spring 인터셉터 기능을 추가하여 로그인이 안된 사용자는 홈으로 바인딩되게 만들었다.
>  ***userId 및 itemId 등 중요 상품 id는 해쉬로 암호화하여 파라미터에 사용하게 바꾸었다.***



### 3. Broken Authentication and Session Management

#### 공격

<img src="https://github.com/gudals-kim/web_vulnerability/blob/delevlop/web/docs/ver1/img/cookiesAuthBroken.png?raw=true">

> 로그인 된 기존 회원

<img src="https://github.com/gudals-kim/web_vulnerability/blob/delevlop/web/docs/ver1/img/cookiesAuthBroken1.png?raw=true">

> 브라우저 개발자 도구를 이용하여 쿠키 변조


#### 결과


<img src="https://github.com/gudals-kim/web_vulnerability/blob/delevlop/web/docs/ver1/img/cookiesAuthBroken2.png?raw=true">

> 로그인 정보가 바뀌었다.

#### 기존 코드
```java
    @PostMapping("/login")
    public String login(@Valid @ModelAttribute LoginForm form, BindingResult
    bindingResult, HttpServletResponse response) {
        if (bindingResult.hasErrors()) {
          return "login/loginForm";
        }
        
        Member loginMember = loginService.login(form.getLoginId(),form.getPassword());
        log.info("login? {}", loginMember);
        
        if (loginMember == null) {
          bindingResult.reject("loginFail", "아이디 또는 비밀번호가 맞지 않습니다.");
          return "login/loginForm";
        }
```

- 취약점 문제
  - 쿠키 값은 임의로 변경할 수 있다.
  - ***클라이언트가 쿠키를 강제로 변경하면 다른 사용자가 된다.***
  - Cookie: memberId=1 Cookie: memberId=2 (다른 사용자의 이름이 보임) 쿠키에 보관된 정보는 훔쳐갈 수 있다.
  - 만약 쿠키에 개인정보나, 신용카드 정보가 있다면?
  - 이 정보가 웹 브라우저에도 보관되고, 네트워크 요청마다 계속 클라이언트에서 서버로 전달된다. 쿠키의 정보가 나의 로컬 PC에서 털릴 수도 있고, 네트워크 전송 구간에서 털릴 수도 있다.
  - 해커가 쿠키를 한번 훔쳐가면 평생 사용할 수 있다.
  - 해커가 쿠키를 훔쳐가서 그 쿠키로 악의적인 요청을 계속 시도할 수 있다.


#### 수정 코드
```java
    @PostMapping("/login")
    public String login(@Valid @ModelAttribute("loginForm") LoginForm loginForm,
                        BindingResult bindingResult,
                        @RequestParam(defaultValue = "/") String redirectURL,
                        HttpServletRequest request){
        if (bindingResult.hasErrors()){
            return "login/loginForm";
        }

        Member loginMember = loginService.login(loginForm.getEmail(), loginForm.getPassword());
        log.debug("loginMember={}",loginMember);
        if (loginMember == null){
            bindingResult.reject("loginFail","아이디 또는 비밀번호가 맞지 않습니다.");
            return "login/loginForm";
        }
        HttpSession session = request.getSession();
        session.setAttribute(LOGIN_MEMBER,loginMember);

        return "redirect:"+redirectURL;
    }
```
- 대안 : 세션을 활용했다.
  - 쿠키에 중요한 값을 노출하지 않고, 사용자 별로 예측 불가능한 임의의 토큰(랜덤 값)을 노출하고, 
  - 서버에서 토큰과 사용자 id를 매핑해서 인식한다. 그리고 서버에서 토큰을 관리한다.
  - 토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 예상 불가능 해야 한다.
  - 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 만료시간을 짧게(예: 30분) 유지한다. 
  - 또는 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 된다.

### 4. xxs